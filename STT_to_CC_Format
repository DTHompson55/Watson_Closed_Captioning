module.exports = {
		toClosedCaption:toClosedCaption};
//
// formatter
//
function toClosedCaption(stt, style){
if ( !style.maxLineTime ) style.maxLineTime = 2.0;
if ( !style.includeHesitations ) style.includeHesitations = false;
if ( style.ccStyle === "srt" )    style.srt = true;
if ( style.ccStyle === "vtt" )     style.vtt = true;

if ( style.vtt     ) cc_out = prologueVtt();
if ( style.srt     ) cc_out = prologueSrt();

//
// variables
//
var timer = 0
var starttimer = 0;
var endtimer = 1;
var frame = 0;
var cc_out;

var frame = 0;
var start_time = 0;

var speaker = 0;
var previousSpeaker = undefined;
var currentSpeaker = 0;
var speakers = [];
var previous_end_time = -1.0;

//
// build a map of speaker labels
//
if ( stt.speaker_labels){
    stt.speaker_labels.map(function (element){
	speakers[element.from]=element.speaker;
	if ( previousSpeaker === undefined){
		previousSpeaker = element.speaker;
	}
});} else {
//	console.log("No Speaker Labels Found");
}

//
// strip out all the timestamp elements into an array
//
var timestamps = stt.results.map(function (element){
	return element.alternatives[0].timestamps;
}).reduce(function(pv,el){
	el.map(function(element){
		return(element);
	}).reduce(function(pv,el){
		return pv.concat(el);
	},[]);
	return pv.concat(el);
},[]);

//
// take all the timestamps and format them as Formatted close caption elements
//
var frames = timestamps.map(function(element){
	return (element);
}).reduce(function(pv,el){	
	if ( !style.includeHesitations ) {
		if ( el[0] == "%HESITATION") return(pv); // This formatter eats the hesitations
	}
	
	currentSpeaker = speakers[el[1]];	
	
	if (currentSpeaker != previousSpeaker){
		end_time = parseFloat(el.end);
		if (pv[frame] ) frame++; // only increment the frame if it is not a new frame
		previousSpeaker = currentSpeaker;
	}

	if (! pv[frame] ) {
		start_time = parseFloat(el.start);
		
		pv[frame] = {words:"",start:el[1], end:el[2], frame:frame, speaker:speakers[el[1]]};
		 start_time = el[1];
		 end_time = start_time + style.maxLineTime;
	} else{
		pv[frame].words+= " ";
	}
	
	pv[frame].words+= el[0];
	pv[frame].end = el[2];
	if (parseFloat(el[2])>end_time){
		end_time = parseFloat(el.end);
		frame++;
		previousSpeaker = currentSpeaker;
	}
	previous_end_time = parseFloat(el.end);
	return(pv);
},[]);

if ( style.vtt     ) cc_out = formatVtt(frames, ( style.suppressMultipleSpeakers?false:previousSpeaker), cc_out);
if ( style.srt     ) cc_out = formatSrt(frames, ( style.suppressMultipleSpeakers?false:previousSpeaker), cc_out);

return cc_out;
}

function formatSrt(frames, previousSpeaker, cc){
    frames.map(function(el){
	cc+= el.frame + "\n";
	cc+= timeFmtSrt(el.start)+" --> "+timeFmtSrt(el.end) + "\n";
	if ( previousSpeaker )
	cc+= "Speaker "+el.speaker+": ";
	cc+= el.words+ "\n\n";
});
return cc;}

function formatVtt(frames, previousSpeaker, cc){
    frames.map(function(el){

	cc+= el.frame + "\n";
	cc+= timeFmtVtt(el.start)+" --> "+timeFmtVtt(el.end) + "\n";
	if ( previousSpeaker )
	cc+= "Speaker "+el.speaker+": ";
	cc+= el.words+ "\n\n";
});
return cc;}

function prologueSrt(){
return "";
}

function prologueVtt(){
return "WEBVTT\n\n";
}

function timeFmt(f){

var t = {};
var	i = Math.floor(f);

t.ms3 = ((""+(f-i).toPrecision(3))+"000").substring(2,5);
t.ms2 = ((""+(f-i).toPrecision(2))+"00").substring(2,4);

t.s = i%60;
t.m = (Math.floor(i/60))%60;
t.h = Math.floor(i/3600);
return t;
}

function timeFmtSrt(f){
	t = timeFmt(f);
	return ""+((t.h<10)?"0"+t.h:t.h)+":" +((t.m<10)?"0"+t.m:t.m)+":" +((t.s<10)?"0"+t.s:t.s)+","+t.ms2;
}

function timeFmtVtt(f){
	t = timeFmt(f);
	return ""+((t.h<10)?"0"+t.h:t.h)+":" +((t.m<10)?"0"+t.m:t.m)+":" +((t.s<10)?"0"+t.s:t.s)+"."+t.ms3;
}

